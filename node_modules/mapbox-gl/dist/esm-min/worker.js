import{bx as e,du as t,fj as s,G as i,fk as o,fl as n,w as r,aP as a,aZ as l,b3 as c,fm as h,fn as u,fo as d,fp as f,fq as p,fr as g,B as m,fs as y,I as w,bb as b,ft as x,ac as v,fu as S,fv as I,b4 as M,fw as P,fx as T,fy as _,ba as k,ea as L,E as z,aL as C,aK as D,aM as j,fz as O,bt as F,fA as A,bs as Z,bu as B,am as N,P as E,fB as R,aG as Y,aJ as X,c4 as J,U as G,m as $,fC as V,fD as U,fE as q,d6 as W,fF as H,fG as Q,x as K,cm as ee,z as te,fH as se,fI as ie,fJ as oe}from"./shared.js";function ne(e){const t=e?e.url.toString():void 0;return t?performance.getEntriesByName(t):[]}function re(e){if("number"==typeof e||"boolean"==typeof e||"string"==typeof e||null==e)return JSON.stringify(e);if(Array.isArray(e)){let t="[";for(const s of e)t+=`${re(s)},`;return`${t}]`}let t="{";for(const s of Object.keys(e).sort())t+=`${s}:${re(e[s])},`;return`${t}}`}function ae(t){let s="";for(const i of e)s+=`/${re(t[i])}`;return s}class le{constructor(e){this.keyCache={},this._layers={},this._layerConfigs={},e&&this.replace(e)}replace(e,t){this._layerConfigs={},this._layers={},this.update(e,[],t)}update(e,s,i){this._options=i;for(const s of e)this._layerConfigs[s.id]=s,(this._layers[s.id]=t(s,this.scope,null,this._options)).compileFilter(i),this.keyCache[s.id]&&delete this.keyCache[s.id];for(const e of s)delete this.keyCache[e],delete this._layerConfigs[e],delete this._layers[e];this.familiesBySource={};const o=function(e,t){const s={};for(let i=0;i<e.length;i++){const o=e[i];let n=t&&t[o.id];n||("symbol"===o.type?n=o.id:(n=ae(o),"line"===o.type&&o.paint&&function e(t){return"string"==typeof t&&"line-progress"===t||(Array.isArray(t)?t.some(e):!(!t||"object"!=typeof t)&&Object.values(t).some(e))}(o.paint["line-width"])&&(n+=`/${re(o.paint["line-width"])}`))),t&&(t[o.id]=n);let r=s[n];r||(r=s[n]=[]),r.push(o)}const i=[];for(const e in s)i.push(s[e]);return i}(Object.values(this._layerConfigs),this.keyCache);for(const e of o){const t=e.map((e=>this._layers[e.id])),s=t[0];if("none"===s.visibility)continue;const i=s.source||"";let o=this.familiesBySource[i];o||(o=this.familiesBySource[i]={});const n=s.sourceLayer||"_geojsonTileLayer";let r=o[n];r||(r=o[n]=[]),r.push(t)}}}const ce=1*n;class he{constructor(e){const t={},s=[];for(const i in e){const o=e[i],n=t[i]={};for(const e in o.glyphs){const t=o.glyphs[+e];if(!t||0===t.bitmap.width||0===t.bitmap.height)continue;const i=t.metrics.localGlyph?ce:1,r={x:0,y:0,w:t.bitmap.width+2*i,h:t.bitmap.height+2*i};s.push(r),n[e]=r}}const{w:n,h:r}=i(s),a=new o({width:n||1,height:r||1});for(const s in e){const i=e[s];for(const e in i.glyphs){const n=i.glyphs[+e];if(!n||0===n.bitmap.width||0===n.bitmap.height)continue;const r=t[s][e],l=n.metrics.localGlyph?ce:1;o.copy(n.bitmap,a,{x:0,y:0},{x:r.x+l,y:r.y+l},n.bitmap)}}this.image=a,this.positions=t}}function ue(e,t,s){e[t]?s&&(e[t].center=s):e[t]={floorIds:new Set,center:s||[0,0],floors:{}}}function de(e,t,s,i){for(const o of t)ue(e,o),e[o].floors[s]=i,e[o].floorIds.add(s)}function fe(e){return{id:e.properties.id.toString(),center:e.properties.center.toString().split(";").map(Number)}}function pe(e){return{id:e.properties.id.toString(),isDefault:!!e.properties.is_default&&e.properties.is_default,connections:e.properties.connected_floor_ids?new Set(e.properties.connected_floor_ids.toString().split(";")):new Set,conflicts:e.properties.conflicted_floor_ids?new Set(e.properties.conflicted_floor_ids.toString().split(";")):new Set,buildings:e.properties.building_ids?new Set(e.properties.building_ids.toString().split(";")):new Set,name:e.properties.name.toString(),zIndex:e.properties.z_index}}function ge(e,t){return t.every((t=>e.properties&&null!=e.properties[t]))}function me(e){return ge(e,["type","id","name"])&&"building"===e.properties.type}function ye(e){return ge(e,["type","id","name","z_index"])&&"floor"===e.properties.type}s(he,"GlyphAtlas");class we{constructor(e){this.tileID=new a(e.tileID.overscaledZ,e.tileID.wrap,e.tileID.canonical.z,e.tileID.canonical.x,e.tileID.canonical.y),this.tileZoom=e.tileZoom,this.uid=e.uid,this.zoom=e.zoom,this.lut=e.lut,this.canonical=e.tileID.canonical,this.pixelRatio=e.pixelRatio,this.tileSize=e.tileSize,this.source=e.source,this.scope=e.scope,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=e.showCollisionBoxes,this.collectResourceTiming=!!e.request&&e.request.collectResourceTiming,this.promoteId=e.promoteId,this.isSymbolTile=e.isSymbolTile,this.tileTransform=l(e.tileID.canonical,e.projection),this.projection=e.projection,this.worldview=e.worldview,this.localizableLayerIds=e.localizableLayerIds,this.brightness=e.brightness,this.extraShadowCaster=!!e.extraShadowCaster,this.tessellationStep=e.tessellationStep,this.scaleFactor=e.scaleFactor,this.worldview=e.worldview,this.indoor=e.indoor}parse(e,t,s,i,o,n){this.status="parsing",this.data=e,this.collisionBoxArray=new c;const a=new h(Object.keys(e.layers).sort()),l=new u(this.tileID,this.promoteId);l.bucketLayerIDs=[];const v={},z=new d(256,256),C={featureIndex:l,iconDependencies:new Map,patternDependencies:new Map,glyphDependencies:{},lineAtlas:z,availableImages:s,brightness:this.brightness,scaleFactor:this.scaleFactor,elevationFeatures:void 0,activeFloors:void 0};if(this.indoor){const t=this.indoor.indoorState.activeFloorsVisible,s=function(e,t,s){const i=function(e,t){if(!e)return r("No source layers defined in indoor specification"),t;if(0===e.size)return t;const s=e.difference(t);for(const e of s)r(`Missing source layer required in indoor specification: ${e}`);return t.intersection(t)}(t.sourceLayers,new Set(Object.keys(e.layers))),o=t.indoorState,n=function(e,t,s,i){const o=new Set,n=new Set,a=new Set,l=new Map,c={},h=e=>{const t=l.get(e)||new Set;for(const s of o)if((l.get(s)||new Set).has(e)||t.has(s))return!0;return!1};for(const s of t){const t=e.layers[s];if(t)for(let e=0;e<t.length;e++){const s=t.feature(e);if(me(s)){const{id:e,center:t}=fe(s);ue(c,e,t),o.add(e)}else if(ye(s)){const{id:e,isDefault:t,connections:r,conflicts:h,buildings:u,name:d,zIndex:f}=pe(s);de(c,u,e,{name:d,zIndex:f}),l.set(e,h),(e===i||r.has(i))&&o.add(e),n.add(e),t&&a.add(e)}}else r(`indoor source layer not found: ${s}`)}if(s)for(const e of s)n.has(e)&&(h(e)||o.add(e));for(const e of a)o.has(e)||h(e)||o.add(e);return{buildings:c,activeFloors:o}}(e,i,o.lastActiveFloors,o.selectedFloorId);return s.send("setIndoorData",n),n}(e,this.indoor,o);C.activeFloors=t?s.activeFloors:void 0}const D=[],j=t.familiesBySource[this.source];for(const t in j){const o=e.layers[t];if(!o)continue;let n=!1,c=!1,h=!1;for(const e of j[t])"symbol"===e[0].type?n=!0:c=!0,e[0].is3D()&&"model"!==e[0].type&&(h=!0);if(this.extraShadowCaster&&!h)continue;if(!0===this.isSymbolTile&&!n)continue;if(!1===this.isSymbolTile&&!c)continue;1===o.version&&r(`Vector tile source "${this.source}" layer "${t}" does not use vector tile spec v2 and therefore may have some rendering errors.`);const u=a.encode(t),d=[],y=this.localizableLayerIds&&this.localizableLayerIds.has(t);let w=!1;for(let e=0,s=0;e<o.length;e++){const i=o.feature(e),n=l.getId(i,t),r=i.properties?i.properties.worldview:null;if(y&&this.worldview&&"string"==typeof r)if("all"===r)i.properties.$localized=!0;else{if(!r.split(",").includes(this.worldview))continue;i.properties.$localized=!0,i.properties.worldview=this.worldview}!w&&i.properties&&i.properties.hasOwnProperty(f)&&(w=!0),d.push({feature:i,id:n,index:s,sourceLayerIndex:u}),s++}w&&!C.elevationFeatures&&e.layers.hasOwnProperty(p)&&(C.elevationFeatures=g.parseFrom(e.layers[p],this.canonical));for(const e of j[t]){const t=e[0];if(this.extraShadowCaster&&(!t.is3D()||"model"===t.type))continue;if(void 0!==this.isSymbolTile&&"symbol"===t.type!==this.isSymbolTile)continue;if(t.minzoom&&this.zoom<Math.floor(t.minzoom))continue;if(t.maxzoom&&this.zoom>=t.maxzoom)continue;if("none"===t.visibility)continue;be(e,this.zoom,C.brightness,s,this.worldview);const o=v[t.id]=t.createBucket({index:l.bucketLayerIDs.length,layers:e,zoom:this.zoom,lut:this.lut,canonical:this.canonical,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:u,sourceID:this.source,projection:this.projection.spec,tessellationStep:this.tessellationStep,styleDefinedModelURLs:i,worldview:this.worldview,localizable:y});l.bucketLayerIDs.push(e.map((e=>m(e.id,e.scope))));let n=o.prepare?o.prepare():null;null!=n?(n=n.then((()=>o.populate(d,C,this.tileID.canonical,this.tileTransform))),D.push(n)):o.populate(d,C,this.tileID.canonical,this.tileTransform)}}const O=()=>{let t,i,r,c,h,u;z.trim();const d={type:"maybePrepare",isSymbolTile:this.isSymbolTile,zoom:this.zoom},f=()=>{if(t)return this.status="done",n(t);if(this.extraShadowCaster)this.status="done",n(null,{buckets:Object.values(v).filter((e=>!e.isEmpty())),featureIndex:l,collisionBoxArray:null,glyphAtlasImage:null,lineAtlas:null,imageAtlas:null,brightness:C.brightness,glyphMap:null,iconMap:null,glyphPositions:null});else if(i&&r&&c){const e=new he(i),t=new Map;for(const[e,s]of r.entries()){const{imagePosition:i}=S(e,s,I);t.set(e,i)}const n={};for(const o in v){const a=v[o];a instanceof M&&(be(a.layers,this.zoom,C.brightness,s,this.worldview),n[o]=P(a,i,e.positions,r,t,this.tileID.canonical,this.tileZoom,this.scaleFactor,this.pixelRatio,h,this.worldview))}const a={iconsPending:!0,patternsPending:!0};this.rasterizeIfNeeded(o,r,h,(()=>{a.iconsPending=!1,p(n,e,a)})),this.rasterizeIfNeeded(o,c,u,(()=>{a.patternsPending=!1,p(n,e,a)}))}},p=(e,t,i,o)=>{if(i.iconsPending||i.patternsPending)return;const a=new T(r,c,this.lut);for(const t in v){const i=v[t];if(t in e)_(i,e[t],this.showCollisionBoxes,s,this.tileID.canonical,this.tileZoom,this.projection,this.brightness,r,a);else if(i.hasPattern&&(i instanceof k||i instanceof b||i instanceof L)){be(i.layers,this.zoom,C.brightness,s,this.worldview);const e=Object.fromEntries(a.patternPositions);i.addFeatures(C,this.tileID.canonical,e,s,this.tileTransform,this.brightness)}}this.status="done",n(null,{buckets:Object.values(v).filter((e=>!e.isEmpty())),featureIndex:l,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,lineAtlas:z,imageAtlas:a,brightness:C.brightness})};if(!this.extraShadowCaster){const e=y(C.glyphDependencies,(e=>Object.keys(e).map(Number)));Object.keys(e).length?o.send("getGlyphs",{uid:this.uid,stacks:e},((e,s)=>{t||(t=e,i=s,f())}),void 0,!1,d):i={};const s=Array.from(C.iconDependencies.keys()).map((e=>w.parse(e)));s.length?o.send("getImages",{images:s,source:this.source,scope:this.scope,tileID:this.tileID,type:"icons"},((e,s)=>{t||(t=e,r=new Map,h=this.updateImageMapAndGetImageTaskQueue(r,s,C.iconDependencies),f())}),void 0,!1,d):(r=new Map,h=new Map);const n=Array.from(C.patternDependencies.keys()).map((e=>w.parse(e)));n.length?o.send("getImages",{images:n,source:this.source,scope:this.scope,tileID:this.tileID,type:"patterns"},((e,s)=>{t||(t=e,c=new Map,u=this.updateImageMapAndGetImageTaskQueue(c,s,C.patternDependencies),f())}),void 0,!1,d):(c=new Map,u=new Map)}if(C.elevationFeatures&&C.elevationFeatures.length>0){const t=[];for(const e of Object.values(v))if(e instanceof b){const s=e.getUnevaluatedPortalGraph();s&&t.push(s)}const s=x.evaluate(t);for(const t of Object.values(v))if(t instanceof b){const i=e.layers[a.decode(t.sourceLayerIndex)];t.setEvaluatedPortalGraph(s,i,this.tileID.canonical,C.availableImages,C.brightness)}}f()};D.length>0?Promise.allSettled(D).then(O).catch(n):O()}updateParameters(e){this.scaleFactor=e.scaleFactor,this.showCollisionBoxes=e.showCollisionBoxes,this.projection=e.projection,this.brightness=e.brightness,this.tileTransform=l(e.tileID.canonical,e.projection),this.extraShadowCaster=e.extraShadowCaster,this.lut=e.lut,this.worldview=e.worldview,this.indoor=e.indoor}rasterizeIfNeeded(e,t,s,i){Array.from(t.values()).some((e=>e.usvg))?this.rasterize(e,t,s,i):i()}updateImageMapAndGetImageTaskQueue(e,t,s){const i=new Map;for(const o of t.keys()){const n=s.get(o)||[];for(const s of n){const o=s.toString(),n=t.get(s.id.toString());n.usvg?i.has(o)||(i.set(o,s),e.set(o,Object.assign({},n))):e.set(o,n)}}return i}rasterize(e,t,s,i){this.rasterizeTask=e.send("rasterizeImages",{scope:this.scope,tasks:s},((e,s)=>{if(!e)for(const[e,i]of s.entries()){const s=Object.assign(t.get(e),{data:i});t.set(e,s)}i()}))}cancelRasterize(){this.rasterizeTask&&this.rasterizeTask.cancel()}}function be(e,t,s,i,o){const n=new v(t,{brightness:s,worldview:o});for(const t of e)t.recalculate(n,i)}class xe extends z{constructor(e,t,s,i,o,n,r){super(),this.actor=e,this.layerIndex=t,this.availableImages=s,this.availableModels=i,this.loadVectorData=n||C,this.loading={},this.loaded={},this.deduped=new D(e.scheduler),this.isSpriteLoaded=o,this.scheduler=e.scheduler,this.brightness=r}loadTile(e,t){const s=e.uid,i=e&&e.request,o=i&&i.collectResourceTiming,n=this.loading[s]=new we(e);n.abort=this.loadVectorData(e,((r,a)=>{const l=!this.loading[s];if(delete this.loading[s],n.cancelRasterize(),l||r||!a)return n.status="done",l||(this.loaded[s]=n),t(r);const c=a.rawData,h={},u=j(a.responseHeaders);u&&u.expires&&(h.expires=u.expires),u&&u.cacheControl&&(h.cacheControl=u.cacheControl),n.vectorTile=a.vectorTile||new O(new F(c));const d=()=>{n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.availableModels,this.actor,((e,s)=>{if(e||!s)return t(e);const n={};if(o){const e=ne(i);e.length>0&&(n.resourceTiming=JSON.parse(JSON.stringify(e)))}t(null,Object.assign({rawTileData:c.slice(0),responseHeaders:a.responseHeaders},s,h,n))}))};this.isSpriteLoaded?d():this.once("isSpriteLoaded",(()=>{this.scheduler?this.scheduler.add(d,{type:"parseTile",isSymbolTile:e.isSymbolTile,zoom:e.tileZoom}):d()})),this.loaded=this.loaded||{},this.loaded[s]=n}))}reloadTile(e,t){const s=this.loaded,i=e.uid;if(s&&s[i]){const o=s[i];o.updateParameters(e);const n=(e,s)=>{const i=o.reloadCallback;i&&(delete o.reloadCallback,o.parse(o.vectorTile,this.layerIndex,this.availableImages,this.availableModels,this.actor,i)),t(e,s)};"parsing"===o.status?o.reloadCallback=n:"done"===o.status&&(o.vectorTile?o.parse(o.vectorTile,this.layerIndex,this.availableImages,this.availableModels,this.actor,n):n())}else t(null,void 0)}abortTile(e,t){const s=e.uid,i=this.loading[s];i&&(i.abort&&i.abort(),delete this.loading[s]),t()}removeTile(e,t){const s=this.loaded,i=e.uid;s&&s[i]&&delete s[i],t()}}class ve{loadTile(e,t){const{uid:s,encoding:i,rawImageData:o,padding:n}=e,r=ImageBitmap&&o instanceof ImageBitmap?this.getImageData(o,n):o;t(null,new A(s,r,i,n<1))}reloadTile(e,t){t(null,null)}abortTile(e,t){t()}removeTile(e,t){t()}getImageData(e,t){this.offscreenCanvas&&this.offscreenCanvasContext||(this.offscreenCanvas=new OffscreenCanvas(e.width,e.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d",{willReadFrequently:!0})),this.offscreenCanvas.width=e.width,this.offscreenCanvas.height=e.height,this.offscreenCanvasContext.drawImage(e,0,0,e.width,e.height);const s=this.offscreenCanvasContext.getImageData(-t,-t,e.width+2*t,e.height+2*t);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),s}}Z.setPbf(F);class Se{constructor(e){this._mrt=new Z(e.partial?30:1/0),this._isHeaderLoaded=!1,this.uid=e.uid,this.tileID=e.tileID,this.source=e.source}parse(e,t){const s=this._mrt;this.status="parsing",this._entireBuffer=e;try{s.parseHeader(e),this._isHeaderLoaded=!0;const i=[];for(const t in s.layers){const o=s.getLayer(t),n=o.getDataRange(o.getBandList()),r=s.createDecodingTask(n),a=e.slice(n.firstByte,n.lastByte+1),l=Z.performDecoding(a,r).then((e=>r.complete(null,e))).catch((e=>r.complete(e,null)));i.push(l)}Promise.allSettled(i).then((()=>t(null,s))).catch((e=>t(e)))}catch(e){t(e)}}}class Ie{constructor(e){this.actor=e,this.loading={},this.loaded={}}loadTile(e,t){const s=e.uid,i=e.request,o=this.loading[s]=new Se(e),{cancel:n}=B(i,((e,i,n)=>{const r=!this.loading[s];if(delete this.loading[s],r||e||!i)return o.status="done",r||(this.loaded[s]=o),t(e);o.parse(i,((e,s)=>{if(e||!s)return t(e);t(null,s,n)})),this.loaded[s]=o}));o.abort=n}reloadTile(e,t){t(null,void 0)}abortTile(e,t){const s=e.uid,i=this.loading[s];i&&(i.abort&&i.abort(),delete this.loading[s]),t()}removeTile(e,t){const s=e.uid;this.loaded[s]&&delete this.loaded[s],t()}decodeRasterArray(e,t){Z.performDecoding(e.buffer,e.task).then((e=>t(null,e))).catch((e=>t(e)))}}const Me=R.prototype.toGeoJSON;class Pe{constructor(e){this._feature=e,this.extent=N,this.type=e.type,this.properties=e.tags,"id"in e&&!isNaN(e.id)&&(this.id=parseInt(e.id,10))}loadGeometry(){if(1===this._feature.type){const e=[];for(const t of this._feature.geometry)e.push([new E(t[0],t[1])]);return e}{const e=[];for(const t of this._feature.geometry){const s=[];for(const e of t)s.push(new E(e[0],e[1]));e.push(s)}return e}}toGeoJSON(e,t,s){return Me.call(this,e,t,s)}}class Te{constructor(e,t){this.name=e,this.extent=N,this.length=t.length,this._jsonFeatures=t}feature(e){return new Pe(this._jsonFeatures[e])}}class _e{constructor(e){this.layers={},this.extent=N;for(const t of Object.keys(e))this.layers[t]=new Te(t,e[t])}}const ke=64/4096,Le=128;class ze{constructor(){this.features=new Map}clear(){this.features.clear()}load(e=[],t){for(const s of e){const e=s.id;if(null==e)continue;let i=this.features.get(e);i&&this.updateCache(i,t),s.geometry?(i=De(s),this.updateCache(i,t),this.features.set(e,i)):this.features.delete(e),this.updateCache(i,t)}}updateCache(e,t){for(const{canonical:s,uid:i}of Object.values(t)){const{z:o,x:n,y:r}=s;Ce(e,Math.pow(2,o),n,r)&&delete t[i]}}getTile(e,t,s){const i=Math.pow(2,e),o=[];for(const e of this.features.values())Ce(e,i,t,s)&&o.push(Ae(e,i,t,s));return{features:o}}getFeatures(){return[...this.features.values()]}}function Ce({minX:e,minY:t,maxX:s,maxY:i},o,n,r){return e<(n+1+ke)/o&&t<(r+1+ke)/o&&s>(n-ke)/o&&i>(r-ke)/o}function De(e){const{id:t,geometry:s,properties:i}=e;if(!s)return;if("GeometryCollection"===s.type)throw new Error("GeometryCollection not supported in dynamic mode.");const{type:o,coordinates:n}=s,r={id:t,type:1,geometry:[],tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0},a=r.geometry;if("Point"===o)je(n,a,r);else if("MultiPoint"===o)for(const e of n)je(e,a,r);else if("LineString"===o)r.type=2,Oe(n,a,r);else if("MultiLineString"===o)r.type=2,Fe(n,a,r);else if("Polygon"===o)r.type=3,Fe(n,a,r,!0);else{if("MultiPolygon"!==o)throw new Error("Input data is not a valid GeoJSON object.");r.type=3;for(const e of n)Fe(e,a,r,!0)}return r}function je([e,t],s,i){const o=Y(e);let n=X(t);n=n<0?0:n>1?1:n,s.push(o,n),i.minX=Math.min(i.minX,o),i.minY=Math.min(i.minY,n),i.maxX=Math.max(i.maxX,o),i.maxY=Math.max(i.maxY,n)}function Oe(e,t,s,i=!1,o=!1){const n=[];for(const t of e)je(t,n,s);t.push(n),i&&function(e,t){let s=0;for(let t=0,i=e.length,o=i-2;t<i;o=t,t+=2)s+=(e[t]-e[o])*(e[t+1]+e[o+1]);if(s>0===t)for(let t=0,s=e.length;t<s/2;t+=2){const i=e[t],o=e[t+1];e[t]=e[s-2-t],e[t+1]=e[s-1-t],e[s-2-t]=i,e[s-1-t]=o}}(n,o)}function Fe(e,t,s,i=!1){for(let o=0;o<e.length;o++)Oe(e[o],t,s,i,0===o)}function Ae(e,t,s,i){const{id:o,type:n,geometry:r,tags:a}=e,l=[];if(1===n)!function(e,t,s,i,o){for(let n=0;n<e.length;n+=2){const r=Math.round(N*(e[n+0]*t-s)),a=Math.round(N*(e[n+1]*t-i));o.push([r,a])}}(r,t,s,i,l);else if(2===n)for(const e of r)Ze(e,t,s,i,l);else if(3===n)for(const e of r)Be(e,t,s,i,l);return{id:o,type:n,geometry:l,tags:a}}function Ze(e,t,s,i,o){const n=-Le,r=N+Le;let a;for(let l=0;l<e.length-2;l+=2){let c=Math.round(N*(e[l+0]*t-s)),h=Math.round(N*(e[l+1]*t-i)),u=Math.round(N*(e[l+2]*t-s)),d=Math.round(N*(e[l+3]*t-i));const f=u-c,p=d-h;c<n&&u<n||(c<n?(h+=Math.round(p*((n-c)/f)),c=n):u<n&&(d=h+Math.round(p*((n-c)/f)),u=n),h<n&&d<n||(h<n?(c+=Math.round(f*((n-h)/p)),h=n):d<n&&(u=c+Math.round(f*((n-h)/p)),d=n),c>=r&&u>=r||(c>=r?(h+=Math.round(p*((r-c)/f)),c=r):u>=r&&(d=h+Math.round(p*((r-c)/f)),u=r),h>=r&&d>=r||(h>=r?(c+=Math.round(f*((r-h)/p)),h=r):d>=r&&(u=c+Math.round(f*((r-h)/p)),d=r),a&&c===a[a.length-1][0]&&h===a[a.length-1][1]||(a=[[c,h]],o.push(a)),a.push([u,d])))))}}function Be(e,t,s,i,o){const n=(s-ke)/t,r=(i-ke)/t,a=(s+1+ke)/t,l=(i+1+ke)/t;function c(e,t){let s=0;return e<n?s|=1:e>a&&(s|=2),t<r?s|=4:t>l&&(s|=8),s}let h=[];for(let t=1;t<=8;t*=2){let s=e[e.length-2],i=e[e.length-1],o=!(c(s,i)&t);for(let u=0;u<e.length;u+=2){const d=e[u],f=e[u+1],p=!(c(d,f)&t);p!==o&&(8&t?h.push(s+(d-s)*(l-i)/(f-i),l):4&t?h.push(s+(d-s)*(r-i)/(f-i),r):2&t?h.push(a,i+(f-i)*(a-s)/(d-s)):1&t&&h.push(n,i+(f-i)*(n-s)/(d-s))),p&&h.push(d,f),s=d,i=f,o=p}if(!(e=h).length||8===t)break;h=[]}const u=[];for(let e=0;e<h.length;e+=2)u.push([Math.round(N*(h[e]*t-s)),Math.round(N*(h[e+1]*t-i))]);o.push(u)}function Ne({name:e,features:t},s){s.writeStringField(1,e),s.writeVarintField(5,N);const i=new Map,o=new Map,n={keys:i,values:o,feature:null};for(const e of t)n.feature=e,s.writeMessage(2,Ee,n);for(const e of i.keys())s.writeStringField(3,e);for(const e of o.keys())s.writeMessage(4,Ge,e)}function Ee(e,t){const s=e.feature;void 0!==s.id&&Number.isSafeInteger(+s.id)&&t.writeVarintField(1,+s.id),s.tags&&t.writeMessage(2,Re,e),t.writeVarintField(3,s.type),t.writeMessage(4,Je,s)}function Re({keys:e,values:t,feature:s},i){for(const o of Object.keys(s.tags)){let n=s.tags[o];if(null===n)continue;let r=e.get(o);void 0===r&&(r=e.size,e.set(o,r)),i.writeVarint(r);const a=typeof n;"string"!==a&&"boolean"!==a&&"number"!==a&&(n=JSON.stringify(n));let l=t.get(n);void 0===l&&(l=t.size,t.set(n,l)),i.writeVarint(l)}}function Ye(e,t){return(t<<3)+(7&e)}function Xe(e){return e<<1^e>>31}function Je(e,t){const{geometry:s,type:i}=e;let o=0,n=0;if(1===i){t.writeVarint(Ye(1,s.length));for(const e of s){const s=e[0]-o,i=e[1]-n;t.writeVarint(Xe(s)),t.writeVarint(Xe(i)),o+=s,n+=i}}else for(const e of s){t.writeVarint(Ye(1,1));const s=e.length-(3===i?1:0);for(let i=0;i<s;i++){1===i&&t.writeVarint(Ye(2,s-1));const r=e[i][0]-o,a=e[i][1]-n;t.writeVarint(Xe(r)),t.writeVarint(Xe(a)),o+=r,n+=a}3===i&&t.writeVarint(Ye(7,1))}}function Ge(e,t){const s=typeof e;"string"===s?t.writeStringField(1,e):"boolean"===s?t.writeBooleanField(7,e):"number"===s&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e))}const $e={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},Ve=Math.fround||(Ue=new Float32Array(1),e=>(Ue[0]=+e,Ue[0]));var Ue;const qe=3,We=5,He=6;class Qe{constructor(e){this.options=Object.assign(Object.create($e),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(e){const{log:t,minZoom:s,maxZoom:i}=this.options;t&&console.time("total time");const o=`prepare ${e.length} points`;t&&console.time(o),this.points=e;const n=[];for(let t=0;t<e.length;t++){const s=e[t];if(!s.geometry)continue;const[i,o]=s.geometry.coordinates,r=Ve(tt(i)),a=Ve(st(o));n.push(r,a,1/0,t,-1,1),this.options.reduce&&n.push(0)}let r=this.trees[i+1]=this._createTree(n);t&&console.timeEnd(o);for(let e=i;e>=s;e--){const s=+Date.now();r=this.trees[e]=this._createTree(this._cluster(r,e)),t&&console.log("z%d: %d clusters in %dms",e,r.numItems,+Date.now()-s)}return t&&console.timeEnd("total time"),this}getClusters(e,t){let s=((e[0]+180)%360+360)%360-180;const i=Math.max(-90,Math.min(90,e[1]));let o=180===e[2]?180:((e[2]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)s=-180,o=180;else if(s>o){const e=this.getClusters([s,i,180,n],t),r=this.getClusters([-180,i,o,n],t);return e.concat(r)}const r=this.trees[this._limitZoom(t)],a=r.range(tt(s),st(n),tt(o),st(i)),l=r.data,c=[];for(const e of a){const t=this.stride*e;c.push(l[t+We]>1?Ke(l,t,this.clusterProps):this.points[l[t+qe]])}return c}getChildren(e){const t=this._getOriginId(e),s=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[s];if(!o)throw new Error(i);const n=o.data;if(t*this.stride>=n.length)throw new Error(i);const r=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=o.within(n[t*this.stride],n[t*this.stride+1],r),l=[];for(const t of a){const s=t*this.stride;n[s+4]===e&&l.push(n[s+We]>1?Ke(n,s,this.clusterProps):this.points[n[s+qe]])}if(0===l.length)throw new Error(i);return l}getLeaves(e,t,s){const i=[];return this._appendLeaves(i,e,t=t||10,s=s||0,0),i}getTile(e,t,s){const i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),{extent:n,radius:r}=this.options,a=r/n,l=(s-a)/o,c=(s+1+a)/o,h={features:[]};return this._addTileFeatures(i.range((t-a)/o,l,(t+1+a)/o,c),i.data,t,s,o,h),0===t&&this._addTileFeatures(i.range(1-a/o,l,1,c),i.data,o,s,o,h),t===o-1&&this._addTileFeatures(i.range(0,l,a/o,c),i.data,-1,s,o,h),h.features.length?h:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const s=this.getChildren(e);if(t++,1!==s.length)break;e=s[0].properties.cluster_id}return t}_appendLeaves(e,t,s,i,o){const n=this.getChildren(t);for(const t of n){const n=t.properties;if(n&&n.cluster?o+n.point_count<=i?o+=n.point_count:o=this._appendLeaves(e,n.cluster_id,s,i,o):o<i?o++:e.push(t),e.length===s)break}return o}_createTree(e){const t=new J(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<e.length;s+=this.stride)t.add(e[s],e[s+1]);return t.finish(),t.data=e,t}_addTileFeatures(e,t,s,i,o,n){for(const r of e){const e=r*this.stride,a=t[e+We]>1;let l,c,h;if(a)l=et(t,e,this.clusterProps),c=t[e],h=t[e+1];else{const s=this.points[t[e+qe]];l=s.properties;const[i,o]=s.geometry.coordinates;c=tt(i),h=st(o)}const u={type:1,geometry:[[Math.round(this.options.extent*(c*o-s)),Math.round(this.options.extent*(h*o-i))]],tags:l};let d;d=a||this.options.generateId?t[e+qe]:this.points[t[e+qe]].id,void 0!==d&&(u.id=d),n.features.push(u)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,t){const{radius:s,extent:i,reduce:o,minPoints:n}=this.options,r=s/(i*Math.pow(2,t)),a=e.data,l=[],c=this.stride;for(let s=0;s<a.length;s+=c){if(a[s+2]<=t)continue;a[s+2]=t;const i=a[s],h=a[s+1],u=e.within(a[s],a[s+1],r),d=a[s+We];let f=d;for(const e of u){const s=e*c;a[s+2]>t&&(f+=a[s+We])}if(f>d&&f>=n){let e,n=i*d,r=h*d,p=-1;const g=(s/c<<5)+(t+1)+this.points.length;for(const i of u){const l=i*c;if(a[l+2]<=t)continue;a[l+2]=t;const h=a[l+We];n+=a[l]*h,r+=a[l+1]*h,a[l+4]=g,o&&(e||(e=this._map(a,s,!0),p=this.clusterProps.length,this.clusterProps.push(e)),o(e,this._map(a,l)))}a[s+4]=g,l.push(n/f,r/f,1/0,g,-1,f),o&&l.push(p)}else{for(let e=0;e<c;e++)l.push(a[s+e]);if(f>1)for(const e of u){const s=e*c;if(!(a[s+2]<=t)){a[s+2]=t;for(let e=0;e<c;e++)l.push(a[s+e])}}}}return l}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,t,s){if(e[t+We]>1){const i=this.clusterProps[e[t+He]];return s?Object.assign({},i):i}const i=this.points[e[t+qe]].properties,o=this.options.map(i);return s&&o===i?Object.assign({},o):o}}function Ke(e,t,s){return{type:"Feature",id:e[t+qe],properties:et(e,t,s),geometry:{type:"Point",coordinates:[(i=e[t],360*(i-.5)),it(e[t+1])]}};var i}function et(e,t,s){const i=e[t+We],o=i>=1e4?`${Math.round(i/1e3)}k`:i>=1e3?Math.round(i/100)/10+"k":i,n=e[t+He],r=-1===n?{}:Object.assign({},s[n]);return Object.assign(r,{cluster:!0,cluster_id:e[t+qe],point_count:i,point_count_abbreviated:o})}function tt(e){return e/360+.5}function st(e){const t=Math.sin(e*Math.PI/180),s=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return s<0?0:s>1?1:s}function it(e){const t=(180-360*e)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function ot(e,t,s,i){let o=i;const n=t+(s-t>>1);let r,a=s-t;const l=e[t],c=e[t+1],h=e[s],u=e[s+1];for(let i=t+3;i<s;i+=3){const t=nt(e[i],e[i+1],l,c,h,u);if(t>o)r=i,o=t;else if(t===o){const e=Math.abs(i-n);e<a&&(r=i,a=e)}}o>i&&(r-t>3&&ot(e,t,r,i),e[r+2]=o,s-r>3&&ot(e,r,s,i))}function nt(e,t,s,i,o,n){let r=o-s,a=n-i;if(0!==r||0!==a){const l=((e-s)*r+(t-i)*a)/(r*r+a*a);l>1?(s=o,i=n):l>0&&(s+=r*l,i+=a*l)}return r=e-s,a=t-i,r*r+a*a}function rt(e,t,s,i){const o={id:e??null,type:t,geometry:s,tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};if("Point"===t||"MultiPoint"===t||"LineString"===t)at(o,s);else if("Polygon"===t)at(o,s[0]);else if("MultiLineString"===t)for(const e of s)at(o,e);else if("MultiPolygon"===t)for(const e of s)at(o,e[0]);return o}function at(e,t){for(let s=0;s<t.length;s+=3)e.minX=Math.min(e.minX,t[s]),e.minY=Math.min(e.minY,t[s+1]),e.maxX=Math.max(e.maxX,t[s]),e.maxY=Math.max(e.maxY,t[s+1])}function lt(e,t,s,i){if(!t.geometry)return;const o=t.geometry.coordinates;if(o&&0===o.length)return;const n=t.geometry.type,r=Math.pow(s.tolerance/((1<<s.maxZoom)*s.extent),2);let a=[],l=t.id;if(s.promoteId?l=t.properties[s.promoteId]:s.generateId&&(l=i||0),"Point"===n)ct(o,a);else if("MultiPoint"===n)for(const e of o)ct(e,a);else if("LineString"===n)ht(o,a,r,!1);else if("MultiLineString"===n){if(s.lineMetrics){for(const s of o)a=[],ht(s,a,r,!1),e.push(rt(l,"LineString",a,t.properties));return}ut(o,a,r,!1)}else if("Polygon"===n)ut(o,a,r,!0);else{if("MultiPolygon"!==n){if("GeometryCollection"===n){for(const o of t.geometry.geometries)lt(e,{id:l,geometry:o,properties:t.properties},s,i);return}throw new Error("Input data is not a valid GeoJSON object.")}for(const e of o){const t=[];ut(e,t,r,!0),a.push(t)}}e.push(rt(l,n,a,t.properties))}function ct(e,t){t.push(dt(e[0]),ft(e[1]),0)}function ht(e,t,s,i){let o,n,r=0;for(let s=0;s<e.length;s++){const a=dt(e[s][0]),l=ft(e[s][1]);t.push(a,l,0),s>0&&(r+=i?(o*l-a*n)/2:Math.sqrt(Math.pow(a-o,2)+Math.pow(l-n,2))),o=a,n=l}const a=t.length-3;t[2]=1,ot(t,0,a,s),t[a+2]=1,t.size=Math.abs(r),t.start=0,t.end=t.size}function ut(e,t,s,i){for(let o=0;o<e.length;o++){const n=[];ht(e[o],n,s,i),t.push(n)}}function dt(e){return e/360+.5}function ft(e){const t=Math.sin(e*Math.PI/180),s=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return s<0?0:s>1?1:s}function pt(e,t,s,i,o,n,r,a){if(i/=t,n>=(s/=t)&&r<i)return e;if(r<s||n>=i)return null;const l=[];for(const t of e){const e=t.geometry;let n=t.type;const r=0===o?t.minX:t.minY,c=0===o?t.maxX:t.maxY;if(r>=s&&c<i){l.push(t);continue}if(c<s||r>=i)continue;let h=[];if("Point"===n||"MultiPoint"===n)gt(e,h,s,i,o);else if("LineString"===n)mt(e,h,s,i,o,!1,a.lineMetrics);else if("MultiLineString"===n)wt(e,h,s,i,o,!1);else if("Polygon"===n)wt(e,h,s,i,o,!0);else if("MultiPolygon"===n)for(const t of e){const e=[];wt(t,e,s,i,o,!0),e.length&&h.push(e)}if(h.length){if(a.lineMetrics&&"LineString"===n){for(const e of h)l.push(rt(t.id,n,e,t.tags));continue}"LineString"!==n&&"MultiLineString"!==n||(1===h.length?(n="LineString",h=h[0]):n="MultiLineString"),"Point"!==n&&"MultiPoint"!==n||(n=3===h.length?"Point":"MultiPoint"),l.push(rt(t.id,n,h,t.tags))}}return l.length?l:null}function gt(e,t,s,i,o){for(let n=0;n<e.length;n+=3){const r=e[n+o];r>=s&&r<=i&&bt(t,e[n],e[n+1],e[n+2])}}function mt(e,t,s,i,o,n,r){let a=yt(e);const l=0===o?xt:vt;let c,h,u=e.start;for(let d=0;d<e.length-3;d+=3){const f=e[d],p=e[d+1],g=e[d+2],m=e[d+3],y=e[d+4],w=0===o?f:p,b=0===o?m:y;let x=!1;r&&(c=Math.sqrt(Math.pow(f-m,2)+Math.pow(p-y,2))),w<s?b>s&&(h=l(a,f,p,m,y,s),r&&(a.start=u+c*h)):w>i?b<i&&(h=l(a,f,p,m,y,i),r&&(a.start=u+c*h)):bt(a,f,p,g),b<s&&w>=s&&(h=l(a,f,p,m,y,s),x=!0),b>i&&w<=i&&(h=l(a,f,p,m,y,i),x=!0),!n&&x&&(r&&(a.end=u+c*h),t.push(a),a=yt(e)),r&&(u+=c)}let d=e.length-3;const f=e[d],p=e[d+1],g=0===o?f:p;g>=s&&g<=i&&bt(a,f,p,e[d+2]),d=a.length-3,n&&d>=3&&(a[d]!==a[0]||a[d+1]!==a[1])&&bt(a,a[0],a[1],a[2]),a.length&&t.push(a)}function yt(e){const t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function wt(e,t,s,i,o,n){for(const r of e)mt(r,t,s,i,o,n,!1)}function bt(e,t,s,i){e.push(t,s,i)}function xt(e,t,s,i,o,n){const r=(n-t)/(i-t);return bt(e,n,s+(o-s)*r,1),r}function vt(e,t,s,i,o,n){const r=(n-s)/(o-s);return bt(e,t+(i-t)*r,n,1),r}function St(e,t){const s=[];for(let i=0;i<e.length;i++){const o=e[i],n=o.type;let r;if("Point"===n||"MultiPoint"===n||"LineString"===n)r=It(o.geometry,t);else if("MultiLineString"===n||"Polygon"===n){r=[];for(const e of o.geometry)r.push(It(e,t))}else if("MultiPolygon"===n){r=[];for(const e of o.geometry){const s=[];for(const i of e)s.push(It(i,t));r.push(s)}}s.push(rt(o.id,n,r,o.tags))}return s}function It(e,t){const s=[];s.size=e.size,void 0!==e.start&&(s.start=e.start,s.end=e.end);for(let i=0;i<e.length;i+=3)s.push(e[i]+t,e[i+1],e[i+2]);return s}function Mt(e,t){if(e.transformed)return e;const s=1<<e.z,i=e.x,o=e.y;for(const n of e.features){const e=n.geometry,r=n.type;if(n.geometry=[],1===r)for(let r=0;r<e.length;r+=2)n.geometry.push(Pt(e[r],e[r+1],t,s,i,o));else for(let r=0;r<e.length;r++){const a=[];for(let n=0;n<e[r].length;n+=2)a.push(Pt(e[r][n],e[r][n+1],t,s,i,o));n.geometry.push(a)}}return e.transformed=!0,e}function Pt(e,t,s,i,o,n){return[Math.round(s*(e*i-o)),Math.round(s*(t*i-n))]}function Tt(e,t,s,i,o){const n=t===o.maxZoom?0:o.tolerance/((1<<t)*o.extent),r={features:[],numPoints:0,numSimplified:0,numFeatures:e.length,source:null,x:s,y:i,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const t of e)_t(r,t,n,o);return r}function _t(e,t,s,i){const o=t.geometry,n=t.type,r=[];if(e.minX=Math.min(e.minX,t.minX),e.minY=Math.min(e.minY,t.minY),e.maxX=Math.max(e.maxX,t.maxX),e.maxY=Math.max(e.maxY,t.maxY),"Point"===n||"MultiPoint"===n)for(let t=0;t<o.length;t+=3)r.push(o[t],o[t+1]),e.numPoints++,e.numSimplified++;else if("LineString"===n)kt(r,o,e,s,!1,!1);else if("MultiLineString"===n||"Polygon"===n)for(let t=0;t<o.length;t++)kt(r,o[t],e,s,"Polygon"===n,0===t);else if("MultiPolygon"===n)for(let t=0;t<o.length;t++){const i=o[t];for(let t=0;t<i.length;t++)kt(r,i[t],e,s,!0,0===t)}if(r.length){let s=t.tags||null;if("LineString"===n&&i.lineMetrics){s={};for(const e in t.tags)s[e]=t.tags[e];s.mapbox_clip_start=o.start/o.size,s.mapbox_clip_end=o.end/o.size}const a={geometry:r,type:"Polygon"===n||"MultiPolygon"===n?3:"LineString"===n||"MultiLineString"===n?2:1,tags:s};null!==t.id&&(a.id=t.id),e.features.push(a)}}function kt(e,t,s,i,o,n){const r=i*i;if(i>0&&t.size<(o?r:i))return void(s.numPoints+=t.length/3);const a=[];for(let e=0;e<t.length;e+=3)(0===i||t[e+2]>r)&&(s.numSimplified++,a.push(t[e],t[e+1])),s.numPoints++;o&&function(e,t){let s=0;for(let t=0,i=e.length,o=i-2;t<i;o=t,t+=2)s+=(e[t]-e[o])*(e[t+1]+e[o+1]);if(s>0===t)for(let t=0,s=e.length;t<s/2;t+=2){const i=e[t],o=e[t+1];e[t]=e[s-2-t],e[t+1]=e[s-1-t],e[s-2-t]=i,e[s-1-t]=o}}(a,n),e.push(a)}const Lt={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};class zt{constructor(e,t){const s=(t=this.options=function(e,t){for(const s in t)e[s]=t[s];return e}(Object.create(Lt),t)).debug;if(s&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");let i=function(e,t){const s=[];if("FeatureCollection"===e.type)for(let i=0;i<e.features.length;i++)lt(s,e.features[i],t,i);else lt(s,"Feature"===e.type?e:{geometry:e},t);return s}(e,t);this.tiles={},this.tileCoords=[],s&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),i=function(e,t){const s=t.buffer/t.extent;let i=e;const o=pt(e,1,-1-s,s,0,-1,2,t),n=pt(e,1,1-s,2+s,0,-1,2,t);return(o||n)&&(i=pt(e,1,-s,1+s,0,-1,2,t)||[],o&&(i=St(o,1).concat(i)),n&&(i=i.concat(St(n,-1)))),i}(i,t),i.length&&this.splitTile(i,0,0,0),s&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(e,t,s,i,o,n,r){const a=[e,t,s,i],l=this.options,c=l.debug;for(;a.length;){i=a.pop(),s=a.pop(),t=a.pop(),e=a.pop();const h=1<<t,u=Ct(t,s,i);let d=this.tiles[u];if(!d&&(c>1&&console.time("creation"),d=this.tiles[u]=Tt(e,t,s,i,l),this.tileCoords.push({z:t,x:s,y:i}),c)){c>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,s,i,d.numFeatures,d.numPoints,d.numSimplified),console.timeEnd("creation"));const e=`z${t}`;this.stats[e]=(this.stats[e]||0)+1,this.total++}if(d.source=e,null==o){if(t===l.indexMaxZoom||d.numPoints<=l.indexMaxPoints)continue}else{if(t===l.maxZoom||t===o)continue;if(null!=o){const e=o-t;if(s!==n>>e||i!==r>>e)continue}}if(d.source=null,0===e.length)continue;c>1&&console.time("clipping");const f=.5*l.buffer/l.extent,p=.5-f,g=.5+f,m=1+f;let y=null,w=null,b=null,x=null,v=pt(e,h,s-f,s+g,0,d.minX,d.maxX,l),S=pt(e,h,s+p,s+m,0,d.minX,d.maxX,l);e=null,v&&(y=pt(v,h,i-f,i+g,1,d.minY,d.maxY,l),w=pt(v,h,i+p,i+m,1,d.minY,d.maxY,l),v=null),S&&(b=pt(S,h,i-f,i+g,1,d.minY,d.maxY,l),x=pt(S,h,i+p,i+m,1,d.minY,d.maxY,l),S=null),c>1&&console.timeEnd("clipping"),a.push(y||[],t+1,2*s,2*i),a.push(w||[],t+1,2*s,2*i+1),a.push(b||[],t+1,2*s+1,2*i),a.push(x||[],t+1,2*s+1,2*i+1)}}getTile(e,t,s){e=+e,t=+t,s=+s;const i=this.options,{extent:o,debug:n}=i;if(e<0||e>24)return null;const r=1<<e,a=Ct(e,t=t+r&r-1,s);if(this.tiles[a])return Mt(this.tiles[a],o);n>1&&console.log("drilling down to z%d-%d-%d",e,t,s);let l,c=e,h=t,u=s;for(;!l&&c>0;)c--,h>>=1,u>>=1,l=this.tiles[Ct(c,h,u)];return l&&l.source?(n>1&&(console.log("found parent tile z%d-%d-%d",c,h,u),console.time("drilling down")),this.splitTile(l.source,c,h,u,e,t,s),n>1&&console.timeEnd("drilling down"),this.tiles[a]?Mt(this.tiles[a],o):null):null}}function Ct(e,t,s){return 32*((1<<e)*s+t)+e}function Dt(e,t){const s=e.tileID.canonical;if(!this._geoJSONIndex)return void t(null,null);const i=this._geoJSONIndex.getTile(s.z,s.x,s.y);if(!i)return void t(null,null);const o=e=>e.tags&&"3d_elevation_id"in e.tags&&"source"in e.tags&&"elevation"===e.tags.source,n=i.features.filter((e=>o(e)));let r={_geojsonTileLayer:i.features};n.length>0&&(r={_geojsonTileLayer:i.features.filter((e=>!o(e))),hd_road_elevation:n});const a=new _e(r),l=function(e){const t=new F;for(const s of Object.keys(e))t.writeMessage(3,Ne,{name:s,features:e[s]});return t.finish()}(r).buffer;t(null,{vectorTile:a,rawData:l})}class jt extends xe{constructor(e,t,s,i,o,n,r){super(e,t,s,i,o,Dt,r),n&&(this.loadGeoJSON=n),this._dynamicIndex=new ze}loadData(e,t){const s=e&&e.request,i=s&&s.collectResourceTiming;this._geoJSONIndex=null,this.loadGeoJSON(e,((o,n)=>{if(o||!n)return t(o);if("object"!=typeof n)return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));{try{if(e.filter){const t=G(e.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if("error"===t.result)throw new Error(t.value.map((e=>`${e.key}: ${e.message}`)).join(", "));n.features=n.features.filter((e=>t.value.evaluate({zoom:0},e)))}e.dynamic?("Feature"===n.type&&(n={type:"FeatureCollection",features:[n]}),e.append||(this._dynamicIndex.clear(),this.loaded={}),this._dynamicIndex.load(n.features,this.loaded),e.cluster&&(n.features=this._dynamicIndex.getFeatures())):this.loaded={},this._geoJSONIndex=e.cluster?new Qe(function({superclusterOptions:e,clusterProperties:t}){if(!t||!e)return e;const s={},i={},o={accumulated:null,zoom:0},n={properties:null},r=Object.keys(t);for(const e of r){const[o,n]=t[e],r=G(n),a=G("string"==typeof o?[o,["accumulated"],["get",e]]:o);s[e]=r.value,i[e]=a.value}return e.map=e=>{n.properties=e;const t={};for(const e of r)t[e]=s[e].evaluate(o,n);return t},e.reduce=(e,t)=>{n.properties=t;for(const t of r)o.accumulated=e[t],e[t]=i[t].evaluate(o,n)},e}(e)).load(n.features):e.dynamic?this._dynamicIndex:function(e,t){return new zt(e,t)}(n,e.geojsonVtOptions)}catch(e){return t(e)}const o={};if(i){const t=ne(s);t&&(o.resourceTiming={},o.resourceTiming[e.source]=JSON.parse(JSON.stringify(t)))}t(null,o)}}))}reloadTile(e,t){const s=this.loaded;return s&&s[e.uid]?e.partial?t(null,void 0):super.reloadTile(e,t):this.loadTile(e,t)}loadGeoJSON(e,t){if(e.request)$(e.request,t);else{if("string"!=typeof e.data)return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));setTimeout((()=>{try{return t(null,JSON.parse(e.data))}catch(s){return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`))}}),0)}}getClusterExpansionZoom(e,t){try{t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId))}catch(e){t(e)}}getClusterChildren(e,t){try{t(null,this._geoJSONIndex.getChildren(e.clusterId))}catch(e){t(e)}}getClusterLeaves(e,t){try{t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset))}catch(e){t(e)}}}class Ot{constructor(e,t,s){this.tileID=new a(e.tileID.overscaledZ,e.tileID.wrap,e.tileID.canonical.z,e.tileID.canonical.x,e.tileID.canonical.y),this.tileZoom=e.tileZoom,this.uid=e.uid,this.zoom=e.zoom,this.canonical=e.tileID.canonical,this.pixelRatio=e.pixelRatio,this.tileSize=e.tileSize,this.source=e.source,this.overscaling=this.tileID.overscaleFactor(),this.projection=e.projection,this.brightness=t,this.worldview=s}parse(e,t,s,i){this.status="parsing";const o=new a(s.tileID.overscaledZ,s.tileID.wrap,s.tileID.canonical.z,s.tileID.canonical.x,s.tileID.canonical.y),n=[],r=t.familiesBySource[s.source],l=new u(o,s.promoteId);l.bucketLayerIDs=[],l.is3DTile=!0,V(e).then((e=>{if(!e)return i(new Error("Could not parse tile"));const t=e.json.extensionsUsed&&e.json.extensionsUsed.includes("MAPBOX_mesh_features")||e.json.asset.extras&&e.json.asset.extras.MAPBOX_mesh_features,a=e.json.extensionsUsed&&e.json.extensionsUsed.includes("EXT_meshopt_compression"),c=new v(this.zoom,{brightness:this.brightness,worldview:this.worldview});for(const i in r)for(const h of r[i]){const i=h[0];l.bucketLayerIDs.push(h.map((e=>m(e.id,e.scope)))),i.recalculate(c,[]);const r=U(e,1/W(s.tileID.canonical)),u=new q(h,r,o,t,a,this.brightness,l,this.worldview);t||(u.needsUpload=!0),n.push(u),u.evaluate(i)}this.status="done",i(null,{buckets:n,featureIndex:l,collisionBoxArray:null,glyphAtlasImage:null,lineAtlas:null,imageAtlas:null,brightness:null})})).catch((e=>i(new Error(e.message))))}}class Ft{constructor(e,t,s,i,o,n,r,a){this.actor=e,this.layerIndex=t,this.availableImages=s,this.availableModels=i,this.brightness=r,this.loading={},this.loaded={},this.worldview=a}loadTile(e,t){const s=e.uid,i=this.loading[s]=new Ot(e,this.brightness,this.worldview);B(e.request,((o,n)=>{const r=!this.loading[s];return delete this.loading[s],r||o?(i.status="done",r||(this.loaded[s]=i),t(o)):n&&0!==n.byteLength?void i.parse(n,this.layerIndex,e,((e,o)=>{i.status="done",this.loaded=this.loaded||{},this.loaded[s]=i,e||!o?t(e):t(null,o)})):(i.status="done",this.loaded[s]=i,t())}))}reloadTile(e,t){const s=this.loaded,i=e.uid;if(s&&s[i]){const o=s[i];o.projection=e.projection,o.brightness=e.brightness;const n=(s,i)=>{o.reloadCallback&&(delete o.reloadCallback,this.loadTile(e,t)),t(s,i)};"parsing"===o.status?o.reloadCallback=n:"done"===o.status&&this.loadTile(e,t)}}abortTile(e,t){const s=e.uid;this.loading[s]&&delete this.loading[s],t()}removeTile(e,t){const s=this.loaded,i=e.uid;s&&s[i]&&delete s[i],t()}}class At{constructor(e){this.self=e,this.actor=new Q(e,this),this.layerIndexes={},this.availableImages={},this.availableModels={},this.isSpriteLoaded={},this.imageRasterizer=new K,this.rtlPluginParsingListeners=[],this.projections={},this.defaultProjection=ee({name:"mercator"}),this.workerSourceTypes={vector:xe,geojson:jt,"raster-dem":ve,"raster-array":Ie,"batched-model":Ft},this.workerSources={},this.self.registerWorkerSource=(e,t)=>{if(this.workerSourceTypes[e])throw new Error(`Worker source with name "${e}" already registered.`);this.workerSourceTypes[e]=t},this.self.registerRTLTextPlugin=e=>{if(se.isParsed())throw new Error("RTL text plugin already registered.");se.setState({pluginStatus:oe.parsed,pluginURL:se.getPluginURL()}),se.applyArabicShaping=e.applyArabicShaping,se.processBidirectionalText=e.processBidirectionalText,se.processStyledBidirectionalText=e.processStyledBidirectionalText;for(const e of this.rtlPluginParsingListeners)e(null,!0);this.rtlPluginParsingListeners=[]}}clearCaches(e,t,s){delete this.layerIndexes[e],delete this.availableImages[e],delete this.availableModels[e],delete this.workerSources[e],s()}checkIfReady(e,t,s){s()}setReferrer(e,t){this.referrer=t}spriteLoaded(e,t){this.isSpriteLoaded[e]||(this.isSpriteLoaded[e]={});const{scope:s,isLoaded:i}=t;if(this.isSpriteLoaded[e][s]=i,this.workerSources[e]&&this.workerSources[e][s])for(const t in this.workerSources[e][s]){const o=this.workerSources[e][s][t];for(const e in o){const t=o[e];t instanceof xe&&(t.isSpriteLoaded=i,t.fire(new te("isSpriteLoaded")))}}}setImages(e,t,s){this.availableImages[e]||(this.availableImages[e]={});const{scope:i,images:o}=t;if(this.availableImages[e][i]=o,this.workerSources[e]&&this.workerSources[e][i]){for(const t in this.workerSources[e][i]){const s=this.workerSources[e][i][t];for(const e in s)s[e].availableImages=o}s()}else s()}setModels(e,{scope:t,models:s},i){if(this.availableModels[e]||(this.availableModels[e]={}),this.availableModels[e][t]=s,this.workerSources[e]&&this.workerSources[e][t]){for(const i in this.workerSources[e][t]){const o=this.workerSources[e][t][i];for(const e in o)o[e].availableModels=s}i()}else i()}setProjection(e,t){this.projections[e]=ee(t)}setBrightness(e,t,s){this.brightness=t,s()}setWorldview(e,t,s){this.worldview=t,s()}setLayers(e,t,s){this.getLayerIndex(e,t.scope).replace(t.layers,t.options),s()}updateLayers(e,t,s){this.getLayerIndex(e,t.scope).update(t.layers,t.removedIds,t.options),s()}loadTile(e,t,s){t.projection=this.projections[e]||this.defaultProjection,this.getWorkerSource(e,t.type,t.source,t.scope).loadTile(t,s)}decodeRasterArray(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).decodeRasterArray(t,s)}reloadTile(e,t,s){t.projection=this.projections[e]||this.defaultProjection,this.getWorkerSource(e,t.type,t.source,t.scope).reloadTile(t,s)}abortTile(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).abortTile(t,s)}removeTile(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).removeTile(t,s)}removeSource(e,t,s){if(!(this.workerSources[e]&&this.workerSources[e][t.scope]&&this.workerSources[e][t.scope][t.type]&&this.workerSources[e][t.scope][t.type][t.source]))return;const i=this.workerSources[e][t.scope][t.type][t.source];delete this.workerSources[e][t.scope][t.type][t.source],void 0!==i.removeSource?i.removeSource(t,s):s()}loadWorkerSource(e,t,s){try{this.self.importScripts(t.url),s()}catch(e){s(e)}}syncRTLPluginState(e,t,s){if(se.isParsed())s(null,!0);else if(se.isParsing())this.rtlPluginParsingListeners.push(s);else try{se.setState(t);const e=se.getPluginURL();!se.isLoaded()||se.isParsed()||se.isParsing()||null==e||(se.setState({pluginStatus:oe.parsing,pluginURL:se.getPluginURL()}),this.self.importScripts(e),se.isParsed()?s(null,!0):this.rtlPluginParsingListeners.push(s))}catch(e){s(e)}}setDracoUrl(e,t){this.dracoUrl=t}getAvailableImages(e,t){this.availableImages[e]||(this.availableImages[e]={});let s=this.availableImages[e][t];return s||(s=[]),s}getAvailableModels(e,t){this.availableModels[e]||(this.availableModels[e]={});let s=this.availableModels[e][t];return s||(s={}),s}getLayerIndex(e,t){this.layerIndexes[e]||(this.layerIndexes[e]={});let s=this.layerIndexes[e][t];return s||(s=this.layerIndexes[e][t]=new le,s.scope=t),s}getWorkerSource(e,t,s,i){const o=this.workerSources;return o[e]||(o[e]={}),o[e][i]||(o[e][i]={}),o[e][i][t]||(o[e][i][t]={}),this.isSpriteLoaded[e]||(this.isSpriteLoaded[e]={}),o[e][i][t][s]||(o[e][i][t][s]=new this.workerSourceTypes[t]({send:(t,s,i,o,n,r)=>this.actor.send(t,s,i,e,n,r),scheduler:this.actor.scheduler},this.getLayerIndex(e,i),this.getAvailableImages(e,i),this.getAvailableModels(e,i),this.isSpriteLoaded[e][i],void 0,this.brightness,this.worldview)),o[e][i][t][s]}rasterizeImagesWorker(e,t,s){const i=new Map;for(const[s,{image:o,imageVariant:n}]of t.tasks.entries()){const r=this.imageRasterizer.rasterize(n,o,t.scope,e);i.set(s,r)}s(void 0,i)}removeRasterizedImages(e,t,s){this.imageRasterizer.removeImagesFromCacheByIds(t.imageIds,t.scope,e),s()}enforceCacheSizeLimit(e,t){ie(t)}getWorkerPerformanceMetrics(e,t,s){s(void 0,void 0)}}H(self)&&(self.worker=new At(self));export{At as default};//# sourceMappingURL=worker.js.map
